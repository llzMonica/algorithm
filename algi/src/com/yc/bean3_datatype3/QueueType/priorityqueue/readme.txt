特点:
    1. 不是FIFO,而根据队列元素的优先级来调整顺序。
    2。 通过二叉最小堆来实现
    3. 因为要比较，所以PriorityQueue要么提供一个Comparator来比较，要么元素本身实现Comparable接口

基础:
   最小堆: 它任意一个非叶子节点的权值，都不大于其左右子节点的权值。 堆顶是最小值


可以通过源码学习   PriorityQueue .

下面是一个应用案例:
某电商平台入驻了大量的商家，商家可以在平台销售商品，用户可以在平台的商家那里购买商品。用户付款后如果对购买到的商品不满意，可以向平台发起投诉。用户对某商家的某件商品的投诉记录会存储在一张表中，表结构如下:
列名	类型	备注
store_id	int	商家id
product_id	int	商品id
remark	string	投诉记录
需求: 找到投诉记录最多的前 3 个商家，目的是在搜索时对其店铺进行降权处理.
思路:
   1. 创建一个小根堆（PriorityQueue 默认就是小根堆）
   2. 小根堆中元素的数量小于 3 的时候就直接向集合中添加元素
   3. 当堆中的元素个数等于 3 的时候，通过 peek 方法取出堆顶元素（最小的那个）与当前遍历到的元素比较
   4. 如果当前遍历到的元素大于堆顶元素，就把原堆顶元素移除，把当前元素加入堆中
   5. 这样使得移除的元素都小于堆中的元素
   6. 所以最后堆中保留下来的就是最大的N个元素

